<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Brief description</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../../index.html" title="cpp-reflection">
<link rel="up" href="../clang.html" title="Chapter&#160;16.&#160;Clang">
<link rel="prev" href="../clang.html" title="Chapter&#160;16.&#160;Clang">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../clang.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../clang.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="implement.clang.description"></a><a class="link" href="description.html" title="Brief description">Brief description</a>
</h4></div></div></div>
<p>
          The reflection implementation represents the metaobjects with compile-time
          constants wrapped in a class template.
        </p>
<h4>
<a name="implement.clang.description.h0"></a>
          <span class="phrase"><a name="implement.clang.description.metaobject_id"></a></span><a class="link" href="description.html#implement.clang.description.metaobject_id">Metaobject
          IDs</a>
        </h4>
<p>
          It adds a new native integral <code class="literal">__metaobject_id</code> type which
          has the same bit-width as the <code class="literal">std::uintptr_t</code> type on
          the platform for which the compiler is built (this allows values of <code class="literal">__metaobject_id</code>
          to represent pointers in the compiler). Unlike other integral types, <code class="literal">__metaobject_id</code>
          does not have any arithmetic operators and no conversions to other integral
          types.
        </p>
<h4>
<a name="implement.clang.description.h1"></a>
          <span class="phrase"><a name="implement.clang.description.metaobjects"></a></span><a class="link" href="description.html#implement.clang.description.metaobjects">Metaobjects</a>
        </h4>
<p>
          The <a class="link" href="../../reflexpr/intro.html#reflexpr.intro.metaobjects" title="Metaobjects">metaobjects</a> are represented
          as specializations of the <code class="literal">std::__metaobject</code> template:
        </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">std</span> <span class="special">{</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="identifier">__metaobject_id</span> <span class="identifier">MoId</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">__metaobject</span>
<span class="special">{</span>
	<span class="identifier">__metaobject</span><span class="special">()</span> <span class="special">=</span> <span class="keyword">default</span><span class="special">;</span>
	<span class="identifier">__metaobject</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">metaobject</span><span class="special">&amp;)</span> <span class="special">=</span> <span class="keyword">default</span><span class="special">;</span>
<span class="special">};</span>

<span class="special">}</span> <span class="comment">// namespace std</span>
</pre>
<p>
          The metaobject ID can be obtained from a metaobject (type) by using the
          internal helper template <code class="literal">__unwrap_id</code>:
        </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">std</span> <span class="special">{</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">__unwrap_id</span><span class="special">;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="identifier">__metaobject_id</span> <span class="identifier">MoId</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">__unwrap_id</span><span class="special">&lt;</span><span class="identifier">__metaobject</span><span class="special">&lt;</span><span class="identifier">MoId</span><span class="special">&gt;&gt;</span>
<span class="special">{</span>
	<span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="identifier">__metaobject_id</span> <span class="identifier">value</span> <span class="special">=</span> <span class="identifier">MoId</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">constexpr</span> <span class="identifier">__metaobject_id</span> <span class="identifier">__unwrap_id_v</span> <span class="special">=</span> <span class="identifier">__unwrap_id</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">;</span>

<span class="special">}</span> <span class="comment">// namespace std</span>
</pre>
<h4>
<a name="implement.clang.description.h2"></a>
          <span class="phrase"><a name="implement.clang.description.is_metaobject"></a></span><a class="link" href="description.html#implement.clang.description.is_metaobject">The
          <code class="literal">is_metaobject</code> trait</a>
        </h4>
<p>
          The <code class="literal"><a class="link" href="../../reflexpr/quickref/is_metaobject.html" title="is_metaobject type-trait">std::is_metaobject</a></code>
          trait can then be implemented as follows:
        </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">std</span> <span class="special">{</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_metaobject</span> <span class="special">:</span> <span class="identifier">false_type</span> <span class="special">{</span> <span class="special">};</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="identifier">__metaobject_id</span> <span class="identifier">MoId</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">is_metaobject</span><span class="special">&lt;</span><span class="identifier">__metaobject</span><span class="special">&lt;</span><span class="identifier">MoId</span><span class="special">&gt;&gt;</span> <span class="special">:</span> <span class="identifier">true_type</span> <span class="special">{</span> <span class="special">}</span>

<span class="special">}</span> <span class="comment">// namespace std</span>
</pre>
<p>
          The invocation of the <code class="literal"><a class="link" href="../../reflexpr/quickref/operator.html" title="reflexpr operator">reflexpr</a></code>
          operator yields specializations of the <code class="literal">std::__metaobject</code>
          template, where the value of the <code class="literal">MoId</code> argument is a
          handle to a representation of the metaobject inside of the compiler, as
          described below.
        </p>
<h4>
<a name="implement.clang.description.h3"></a>
          <span class="phrase"><a name="implement.clang.description.metaobject_ops"></a></span><a class="link" href="description.html#implement.clang.description.metaobject_ops">Metaobject
          operations</a>
        </h4>
<p>
          The metaobject operations and concepts are implemented with the help of
          compiler built-ins which take one or several arguments where at least one
          which is a <span class="emphasis"><em>metaobject ID</em></span> (i.e. a compile-time constant
          of the <code class="literal">__metaobject_id</code> type).
        </p>
<p>
          These built-ins are then used in the definition of the class templates,
          template aliases and concepts which implement the public interface of the
          metaobject.
        </p>
<p>
          The built-ins can yield compile-time constant <span class="emphasis"><em>values</em></span>
          of the following types:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              <span class="emphasis"><em>boolean constants</em></span> -- used mostly by the metaobject
              concept definitions like <code class="literal"><a class="link" href="../../reflexpr/quickref/c_Named.html" title="Named">std::meta::Named</a></code>,
              <code class="literal"><a class="link" href="../../reflexpr/quickref/c_ScopeMember.html" title="ScopeMember">std::meta::ScopeMember</a></code>,
              etc. and operations like <code class="literal"><a class="link" href="../../reflexpr/quickref/c_Named.html#reflexpr.quickref.c_Named.ops">std::meta::is_anonymous</a></code>.
            </li>
<li class="listitem">
              <span class="emphasis"><em>integral constants</em></span> -- for operations like <code class="literal"><a class="link" href="../../reflexpr/quickref/c_Object.html#reflexpr.quickref.c_Object.ops">std::meta::get_source_line</a></code>
              or <code class="literal"><a class="link" href="../../reflexpr/quickref/c_ObjectSequence.html#reflexpr.quickref.c_ObjectSequence.ops">std::meta::get_size</a></code>
              and <code class="literal"><a class="link" href="../../reflexpr/quickref/c_Constant.html#reflexpr.quickref.c_Constant.ops">std::meta::get_constant</a></code>.
            </li>
<li class="listitem">
              <span class="emphasis"><em>pointer constants</em></span> -- for operations like <code class="literal"><a class="link" href="../../reflexpr/quickref/c_Variable.html#reflexpr.quickref.c_Variable.ops">std::meta::get_pointer</a></code>.
            </li>
<li class="listitem">
              <span class="emphasis"><em>c-string literals</em></span> -- for operations like <code class="literal"><a class="link" href="../../reflexpr/quickref/c_Object.html#reflexpr.quickref.c_Object.ops">std::meta::get_source_file</a></code>
              or <code class="literal"><a class="link" href="../../reflexpr/quickref/c_Named.html#reflexpr.quickref.c_Named.ops">std::meta::get_base_name</a></code>.
            </li>
<li class="listitem">
              <span class="emphasis"><em>metaobject IDs</em></span> -- for operations like <code class="literal"><a class="link" href="../../reflexpr/quickref/c_ScopeMember.html#reflexpr.quickref.c_ScopeMember.ops">std::meta::get_scope</a></code>,
              <code class="literal"><a class="link" href="../../reflexpr/quickref/c_Class.html#reflexpr.quickref.c_Class.ops">std::meta::get_base_classes</a></code>
              or <code class="literal"><a class="link" href="../../reflexpr/quickref/c_ObjectSequence.html#reflexpr.quickref.c_ObjectSequence.ops">std::meta::get_element</a></code>.
            </li>
</ul></div>
<p>
          So for example the <code class="literal">Named</code> concept is implemented with
          the help of the <code class="literal">__metaobject_is_meta_named</code> compiler
          built-in which returns a boolean compile time constant (equivalent to the
          following pseudocode):
        </p>
<pre class="programlisting"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="identifier">__metaobject_is_meta_named</span><span class="special">(</span><span class="identifier">__metaobject_id</span> <span class="identifier">moid</span><span class="special">);</span>
</pre>
<p>
          The concept as defined in the specification can be then implemented in
          the following manner:
        </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">std</span> <span class="special">{</span>
<span class="keyword">namespace</span> <span class="identifier">meta</span> <span class="special">{</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">concept</span> <span class="keyword">bool</span> <span class="identifier">Object</span> <span class="special">=</span> <span class="identifier">is_metaobject</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="identifier">Object</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="identifier">concept</span> <span class="keyword">bool</span> <span class="identifier">Named</span> <span class="special">=</span> <span class="identifier">__metaobject_is_meta_named</span><span class="special">(</span><span class="identifier">__unwrap_id</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;);</span>

<span class="special">}</span> <span class="comment">// namespace meta</span>
<span class="special">}</span> <span class="comment">// namespace std</span>
</pre>
<p>
          The <code class="literal">get_base_name</code> operation is implemented with the
          help of the <code class="literal">__metaobject_get_base_name</code> built-in resulting
          in a constexpr <code class="literal">char</code> array:
        </p>
<pre class="programlisting"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> <span class="special">[]</span> <span class="identifier">__metaobject_get_base_name</span><span class="special">(</span><span class="identifier">__metaobject_id</span> <span class="identifier">moid</span><span class="special">);</span>
</pre>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">std</span> <span class="special">{</span>
<span class="keyword">namespace</span> <span class="identifier">meta</span> <span class="special">{</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="identifier">Named</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">get_base_name</span>
<span class="special">{</span>
	<span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> <span class="identifier">value</span><span class="special">[]</span> <span class="special">=</span>
		<span class="identifier">__metaobject_get_base_name</span><span class="special">(</span><span class="identifier">__unwrap_id_v</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;);</span>
<span class="special">};</span>

<span class="special">}</span> <span class="comment">// namespace meta</span>
<span class="special">}</span> <span class="comment">// namespace std</span>
</pre>
<p>
          There is also the <code class="literal"><a class="link" href="../../reflexpr/quickref/c_Type.html#reflexpr.quickref.c_Type.ops">std::meta::get_reflected_type</a></code>
          operation which instead of a compile-time constant <span class="emphasis"><em>value</em></span>,
          yields a <span class="emphasis"><em>type</em></span>. This operation is implemented by the
          <code class="literal">__unrefltype</code> built-in operator:
        </p>
<pre class="programlisting"><span class="identifier">unspecified</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">__unrefltype</span><span class="special">(</span><span class="identifier">__metaobject_id</span><span class="special">);</span>
</pre>
<p>
          The template <code class="literal">get_reflected_type</code> is then implemented
          as follows:
        </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">std</span> <span class="special">{</span>
<span class="keyword">namespace</span> <span class="identifier">meta</span> <span class="special">{</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="identifier">Type</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">struct</span> <span class="identifier">get_reflected_type</span>
<span class="special">{</span>
	<span class="keyword">using</span> <span class="identifier">type</span> <span class="special">=</span> <span class="identifier">__unrefltype</span><span class="special">(</span><span class="identifier">__unwrap_id_v</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;);</span>
<span class="special">};</span>

<span class="special">}</span> <span class="comment">// namespace meta</span>
<span class="special">}</span> <span class="comment">// namespace std</span>
</pre>
<h4>
<a name="implement.clang.description.h4"></a>
          <span class="phrase"><a name="implement.clang.description.internal_rep"></a></span><a class="link" href="description.html#implement.clang.description.internal_rep">Internal
          representation</a>
        </h4>
<p>
          The implementation adds the following new expression types to <span class="emphasis"><em>clang</em></span>:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
<p class="simpara">
              <code class="literal">ReflexprExpr</code> -- this class internally represents
              the <a class="link" href="../../reflexpr/intro.html#reflexpr.intro.metaobjects" title="Metaobjects">metaobjects</a>.
              Instances of this expression class are generated when the <code class="literal"><a class="link" href="../../reflexpr/quickref/operator.html" title="reflexpr operator">reflexpr</a></code> operator
              is parsed in the input source code or by some of the metaobject operations
              which return other metaobjects.
            </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                  In the compiled source code these expressions are represented by
                  <span class="emphasis"><em>metaobject IDs</em></span> -- compile-time integral constants
                  of the <code class="literal">__metaobject_id</code> the which can be mapped
                  back to the instances of <code class="literal">ReflexprExpr</code> maintained
                  by the compiler.
                </li>
<li class="listitem">
                  The metaobject IDs are however hashed and randomized between different
                  translation units, so that it is very unlikely that two metaobject
                  IDs, even in two different translation units will have the same
                  value.
                </li>
</ul></div>
</li>
<li class="listitem">
              <code class="literal">MetaobjectIdExpr</code> -- this expression type represents
              an <span class="quote">&#8220;<span class="quote">empty</span>&#8221;</span> literal of <code class="literal">__metaobject_id</code>
              type.
            </li>
<li class="listitem">
              <code class="literal">UnaryMetaobjectOpExpr</code> -- represents compiler built-ins
              implementing unary metaobject operations.
            </li>
<li class="listitem">
              <code class="literal">NaryMetaobjectOpExpr</code> -- represents compiler built-ins
              implementing metaobject operations with arity higher than one (binary,
              etc.).
            </li>
</ul></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Mat&#250;&#353; Chochl&#237;k<p>
        Distributed under the Boost Software License, Version 1.0. See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../clang.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../clang.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a>
</div>
</body>
</html>
